# Python Threading Tutorial

## 1. Introduction to Threading in Python
Threading in Python allows concurrent execution of multiple tasks, enabling efficient multitasking. The `threading` module provides a way to create and manage threads easily.

---

## 2. Single Task Threading
A single-threaded application executes tasks sequentially. Using threading, we can run a single function asynchronously.

```python
import threading
import time

def single_task():
    print("Task started")
    time.sleep(2)
    print("Task completed")

thread = threading.Thread(target=single_task)
thread.start()
thread.join()  # Wait for the thread to finish before exiting
print("Main thread execution completed")
```

---

## 3. Multitasking with Multiple Threads
Multitasking involves running multiple functions concurrently using multiple threads.

```python
import threading
import time

def task1():
    for i in range(5):
        print(f"Task 1 - Count: {i}")
        time.sleep(1)

def task2():
    for i in range(5):
        print(f"Task 2 - Count: {i}")
        time.sleep(1)

thread1 = threading.Thread(target=task1)
thread2 = threading.Thread(target=task2)

thread1.start()
thread2.start()

thread1.join()
thread2.join()
print("Both tasks completed")
```
------------------
### Real-World Example: Downloading Multiple Files Simultaneously
In real-world applications, threading is useful for tasks like downloading multiple files concurrently.

```python
import threading
import time

def download_file(file_name):
    print(f"Starting download: {file_name}")
    time.sleep(3)  # Simulate download time
    print(f"Download complete: {file_name}")

files = ["file1.zip", "file2.zip", "file3.zip"]
threads = []

for file in files:
    thread = threading.Thread(target=download_file, args=(file,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("All downloads completed")
```

This example demonstrates how threading can be used to speed up downloading multiple files instead of processing them sequentially.


## 1. Web Scraping Multiple Pages Concurrently
Instead of fetching web pages sequentially, multiple threads can fetch different pages simultaneously, improving efficiency.

```python

import threading
import requests

def fetch_url(url):
    response = requests.get(url)
    print(f"Fetched {url} with {len(response.content)} bytes")

urls = [
    "https://example.com",
    "https://www.python.org",
    "https://www.github.com"
]

threads = []

for url in urls:
    thread = threading.Thread(target=fetch_url, args=(url,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("All URLs fetched")
```

## 2. Processing Large Dataset in Parallel
If you have a large dataset, you can split it into smaller chunks and process them in parallel using multiple threads.
```python
import threading

data_chunks = [
    list(range(100000)),  # First chunk
    list(range(100000, 200000)),  # Second chunk
    list(range(200000, 300000)),  # Third chunk
]

def process_data(data):
    print(f"Processing {len(data)} records")
    result = sum(data)  # Simulating data processing
    print(f"Processing complete: {result}")

threads = []

for chunk in data_chunks:
    thread = threading.Thread(target=process_data, args=(chunk,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("All data processed")

```
## 3. Handling Multiple User Requests in a Web Server
In a web server, multiple threads handle different user requests simultaneously to improve response times.
```python
import threading
import time

def handle_request(user_id):
    print(f"Handling request for user {user_id}")
    time.sleep(2)  # Simulating request processing time
    print(f"Request completed for user {user_id}")

user_requests = [1, 2, 3, 4, 5]
threads = []

for user_id in user_requests:
    thread = threading.Thread(target=handle_request, args=(user_id,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("All user requests handled")
```


---

## 4. Thread Communication (Using Queue)
Threads can communicate with each other using a queue to share data safely.

```python
import threading
import queue
import time

def producer(q):
    for i in range(5):
        time.sleep(1)
        q.put(i)
        print(f"Produced: {i}")

def consumer(q):
    while True:
        item = q.get()
        if item is None:
            break
        print(f"Consumed: {item}")
        time.sleep(2)

q = queue.Queue()
producer_thread = threading.Thread(target=producer, args=(q,))
consumer_thread = threading.Thread(target=consumer, args=(q,))

producer_thread.start()
consumer_thread.start()

producer_thread.join()
q.put(None)  # Signal the consumer to exit
consumer_thread.join()
print("Thread communication completed")
```

---

## 5. Thread Synchronization (Using Lock)
To prevent race conditions, we use locks to ensure that only one thread accesses a shared resource at a time.

```python
import threading
import time

def task(lock):
    with lock:
        print(f"{threading.current_thread().name} has acquired the lock")
        time.sleep(2)
        print(f"{threading.current_thread().name} has released the lock")

lock = threading.Lock()

threads = [threading.Thread(target=task, args=(lock,)) for _ in range(3)]

for t in threads:
    t.start()
for t in threads:
    t.join()
print("Synchronization complete")
```
# another Ticket booking example for Multitask at same time

```python
import threading
import time

class TicketBooking:
    def __init__(self, available_tickets):
        self.available_tickets = available_tickets  # Shared resource

    def book_ticket(self, name):
        print(f"{name} is trying to book a ticket...")
        if self.available_tickets > 0:
            time.sleep(1)  # Simulate delay
            self.available_tickets -= 1  # Reduce ticket count
            print(f"{name} successfully booked a ticket! Remaining: {self.available_tickets}")
        else:
            print(f"Sorry {name}, no tickets available!")

# Creating a shared TicketBooking object
booking_system = TicketBooking(1)

# Multiple users trying to book at the same time
threads = []
users = ["Alice", "Bob"]
for user in users:
    t = threading.Thread(target=booking_system.book_ticket, args=(user,))
    threads.append(t)
    t.start()

# Wait for all threads to complete
for t in threads:
    t.join()
```
## Problem without Lock:
If two users (Alice & Bob) check at the same time that one ticket is available, they both proceed.

Since there's a delay (time.sleep(1)) before updating the available_tickets, both may end up booking the same ticket.

This results in incorrect remaining ticket count or even overbooking.


# How to overcome the above problem using Lock()
**Solution Using lock (To Prevent Race Condition)**
We can use threading.Lock() to synchronize access to the available_tickets variable.
```python
import threading
import time

class TicketBooking:
    def __init__(self, available_tickets):
        self.available_tickets = available_tickets  # Shared resource
        self.lock = threading.Lock()  # Lock object

    def book_ticket(self, name):
        print(f"{name} is trying to book a ticket...")
        with self.lock:  # Ensures only one thread accesses this block at a time
            if self.available_tickets > 0:
                time.sleep(1)  # Simulate delay
                self.available_tickets -= 1  # Reduce ticket count
                print(f"{name} successfully booked a ticket! Remaining: {self.available_tickets}")
            else:
                print(f"Sorry {name}, no tickets available!")

# Creating a shared TicketBooking object
booking_system = TicketBooking(1)

# Multiple users trying to book at the same time
threads = []
users = ["Alice", "Bob"]
for user in users:
    t = threading.Thread(target=booking_system.book_ticket, args=(user,))
    threads.append(t)
    t.start()

# Wait for all threads to complete
for t in threads:
    t.join()

```
## How This Works?
with self.lock: ensures that only one thread executes the ticket booking logic at a time.

It prevents multiple users from booking the same ticket.
Now, if Alice starts booking, Bob has to wait until Aliceâ€™s transaction completes before checking ticket availability
---

## 6. Daemon Threads
A daemon thread is a background thread that runs continuously and performs tasks like **garbage collection, logging, or monitoring**.

**ðŸš€ Key Feature:**

Daemon threads automatically terminate when the main program (or non-daemon threads) exit.

They are useful for background tasks that shouldn't prevent the program from ending.

# Why Should You Use a Daemon Thread?
You should use a daemon thread when:

You donâ€™t need the thread to finish before the program exits.
The thread runs in the background (e.g., auto-saving, monitoring logs, scheduled tasks).
You donâ€™t want to manually stop the thread.
## ðŸ›‘ When Not to Use a Daemon Thread?

If the thread is performing a critical operation (e.g., writing to a database), use a normal (non-daemon) thread instead.

# Example: Without Daemon Thread (Blocking Execution)

```python
import threading
import time

def background_task():
    for i in range(5):
        print(f"Daemon thread running {i}")
        time.sleep(2)

t = threading.Thread(target=background_task)
t.start()  # Starts the thread (but not as a daemon)

print("Main program exits, but thread keeps running...")

```
# Example: With Daemon Thread (Auto Stops)
```python
import threading
import time

def background_task():
    for i in range(5):
        print(f"Daemon thread running {i}")
        time.sleep(2)

t = threading.Thread(target=background_task, daemon=True)  # ðŸ‘ˆ Daemon thread
t.start()

print("Main program exits, daemon thread will be killed automatically.")

```

---

## 7. Conclusion
This tutorial covered:
- Single task threading
- Multitasking with threads
- Thread communication using a queue
- Thread synchronization using a lock
- Daemon threads

Threading in Python helps achieve concurrency, but due to the Global Interpreter Lock (GIL), it is best used for I/O-bound tasks rather than CPU-bound operations.
