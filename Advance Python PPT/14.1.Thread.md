# Python Threading Tutorial

## 1. Introduction to Threading in Python
Threading in Python allows concurrent execution of multiple tasks, enabling efficient multitasking. The `threading` module provides a way to create and manage threads easily.

---

## 2. Single Task Threading
A single-threaded application executes tasks sequentially. Using threading, we can run a single function asynchronously.

```python
import threading
import time

def single_task():
    print("Task started")
    time.sleep(2)
    print("Task completed")

thread = threading.Thread(target=single_task)
thread.start()
thread.join()  # Wait for the thread to finish before exiting
print("Main thread execution completed")
```

---

## 3. Multitasking with Multiple Threads
Multitasking involves running multiple functions concurrently using multiple threads.

```python
import threading
import time

def task1():
    for i in range(5):
        print(f"Task 1 - Count: {i}")
        time.sleep(1)

def task2():
    for i in range(5):
        print(f"Task 2 - Count: {i}")
        time.sleep(1)

thread1 = threading.Thread(target=task1)
thread2 = threading.Thread(target=task2)

thread1.start()
thread2.start()

thread1.join()
thread2.join()
print("Both tasks completed")
```
------------------
### Real-World Example: Downloading Multiple Files Simultaneously
In real-world applications, threading is useful for tasks like downloading multiple files concurrently.

```python
import threading
import time

def download_file(file_name):
    print(f"Starting download: {file_name}")
    time.sleep(3)  # Simulate download time
    print(f"Download complete: {file_name}")

files = ["file1.zip", "file2.zip", "file3.zip"]
threads = []

for file in files:
    thread = threading.Thread(target=download_file, args=(file,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("All downloads completed")
```

This example demonstrates how threading can be used to speed up downloading multiple files instead of processing them sequentially.


## 1. Web Scraping Multiple Pages Concurrently
Instead of fetching web pages sequentially, multiple threads can fetch different pages simultaneously, improving efficiency.

```python

import threading
import requests

def fetch_url(url):
    response = requests.get(url)
    print(f"Fetched {url} with {len(response.content)} bytes")

urls = [
    "https://example.com",
    "https://www.python.org",
    "https://www.github.com"
]

threads = []

for url in urls:
    thread = threading.Thread(target=fetch_url, args=(url,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("All URLs fetched")
```

## 2. Processing Large Dataset in Parallel
If you have a large dataset, you can split it into smaller chunks and process them in parallel using multiple threads.
```python
import threading

data_chunks = [
    list(range(100000)),  # First chunk
    list(range(100000, 200000)),  # Second chunk
    list(range(200000, 300000)),  # Third chunk
]

def process_data(data):
    print(f"Processing {len(data)} records")
    result = sum(data)  # Simulating data processing
    print(f"Processing complete: {result}")

threads = []

for chunk in data_chunks:
    thread = threading.Thread(target=process_data, args=(chunk,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("All data processed")

```
## 3. Handling Multiple User Requests in a Web Server
In a web server, multiple threads handle different user requests simultaneously to improve response times.
```python
import threading
import time

def handle_request(user_id):
    print(f"Handling request for user {user_id}")
    time.sleep(2)  # Simulating request processing time
    print(f"Request completed for user {user_id}")

user_requests = [1, 2, 3, 4, 5]
threads = []

for user_id in user_requests:
    thread = threading.Thread(target=handle_request, args=(user_id,))
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()

print("All user requests handled")
```
---

## 4. Thread Communication (Using Queue)
Threads can communicate with each other using a queue to share data safely.

```python
import threading
import queue
import time

def producer(q):
    for i in range(5):
        time.sleep(1)
        q.put(i)
        print(f"Produced: {i}")

def consumer(q):
    while True:
        item = q.get()
        if item is None:
            break
        print(f"Consumed: {item}")
        time.sleep(2)

q = queue.Queue()
producer_thread = threading.Thread(target=producer, args=(q,))
consumer_thread = threading.Thread(target=consumer, args=(q,))

producer_thread.start()
consumer_thread.start()

producer_thread.join()
q.put(None)  # Signal the consumer to exit
consumer_thread.join()
print("Thread communication completed")
```

---

## 5. Thread Synchronization (Using Lock)
To prevent race conditions, we use locks to ensure that only one thread accesses a shared resource at a time.

```python
import threading
import time

def task(lock):
    with lock:
        print(f"{threading.current_thread().name} has acquired the lock")
        time.sleep(2)
        print(f"{threading.current_thread().name} has released the lock")

lock = threading.Lock()

threads = [threading.Thread(target=task, args=(lock,)) for _ in range(3)]

for t in threads:
    t.start()
for t in threads:
    t.join()
print("Synchronization complete")
```

---

## 6. Daemon Threads
Daemon threads run in the background and terminate when the main program exits.

```python
import threading
import time

def daemon_task():
    while True:
        print("Daemon thread running...")
        time.sleep(1)

daemon_thread = threading.Thread(target=daemon_task, daemon=True)
daemon_thread.start()

time.sleep(3)
print("Main thread exiting")
```

---

## 7. Conclusion
This tutorial covered:
- Single task threading
- Multitasking with threads
- Thread communication using a queue
- Thread synchronization using a lock
- Daemon threads

Threading in Python helps achieve concurrency, but due to the Global Interpreter Lock (GIL), it is best used for I/O-bound tasks rather than CPU-bound operations.
