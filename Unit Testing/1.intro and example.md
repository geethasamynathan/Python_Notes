# Unit Testing in Python

## What is Unit Testing in Python?

Unit testing in Python refers to the process of testing individual units (functions, methods, or classes) of code in isolation to ensure they work as expected. It helps identify and fix bugs early in the development cycle.

Python provides the `unittest module` to create and run unit tests.

## Why Use Unit Testing?

**Ensures Code Reliability** - Detects errors at an early stage.

**Automates Testing** - Avoids the need for manual testing.

**Enhances Code Refactoring** - Prevents unintended side effects while modifying code.

**Improves Maintainability** - Ensures the stability of code over time.

## When to Use Unit Testing?

When developing a new feature to ensure correctness.

After making changes to existing code to avoid regressions.

When fixing a bug to ensure it doesn’t reappear.

During Continuous Integration (CI) to automate testing before deployment.

## Example: Testing a Banking System

Let’s consider a simple banking system with a BankAccount class. We will write unit tests for deposit and withdrawal functionalities.

## Step 1: Implement the BankAccount Class
```python
class BankAccount:
    def __init__(self, owner, balance=0.0):
        """
        Initializes the bank account with the owner's name and initial balance.
        """
        self.owner = owner
        self.balance = balance

    def deposit(self, amount):
        """
        Deposits a given amount to the bank account.
        """
        if amount > 0:
            self.balance += amount
            return self.balance
        else:
            raise ValueError("Deposit amount must be positive.")

    def withdraw(self, amount):
        """
        Withdraws a given amount from the bank account if sufficient balance exists.
        """
        if amount > self.balance:
            raise ValueError("Insufficient funds.")
        elif amount <= 0:
            raise ValueError("Withdrawal amount must be positive.")
        else:
            self.balance -= amount
            return self.balance
```
## Step 2: Write Unit Tests

Now, we will create a unit test using Python's unittest module.
```python
import unittest
from bank_account import BankAccount  # Import the class from the actual module

class TestBankAccount(unittest.TestCase):

    def setUp(self):
        """
        This method runs before every test case. It sets up a fresh account.
        """
        self.account = BankAccount("John Doe", 100.0)  # Initial balance is 100

    def test_deposit_valid(self):
        """
        Test case for depositing a valid amount.
        """
        self.assertEqual(self.account.deposit(50), 150)  # Balance should be 150

    def test_deposit_invalid(self):
        """
        Test case for depositing a negative amount, which should raise an error.
        """
        with self.assertRaises(ValueError):
            self.account.deposit(-20)

    def test_withdraw_valid(self):
        """
        Test case for withdrawing a valid amount.
        """
        self.assertEqual(self.account.withdraw(30), 70)  # Balance should be 70

    def test_withdraw_insufficient_funds(self):
        """
        Test case for withdrawing an amount greater than the balance.
        """
        with self.assertRaises(ValueError):
            self.account.withdraw(200)  # Should raise an error

    def test_withdraw_negative_amount(self):
        """
        Test case for withdrawing a negative amount.
        """
        with self.assertRaises(ValueError):
            self.account.withdraw(-10)

if __name__ == '__main__':
    unittest.main()
```

##  Step 3: Explanation of Code

### BankAccount Class

**__init__ Method:** Initializes the account with an owner and balance.

**deposit Method:** Adds money to the balance. Throws an error for negative amounts.

**withdraw Method:** Deducts money if sufficient balance exists. Throws an error for negative amounts or insufficient funds.

### Unit Test Class (TestBankAccount)

**setUp():** Runs before each test to create a fresh account.

**test_deposit_valid():** Tests a valid deposit.

**test_deposit_invalid():** Ensures negative deposits raise an error.

**test_withdraw_valid():** Tests withdrawing an allowed amount.

**test_withdraw_insufficient_funds():** Checks for errors when overdrawing.

**test_withdraw_negative_amount():** Ensures withdrawal of negative amounts raises an error.

### Step 4: Running the Tests

Save the test file as test_bank_account.py and run:

`python -m unittest test_bank_account.py`

If all tests pass, you will see:

Ran 5 tests in 0.002s

OK

If a test fails, unittest will show the failed test case and the reason.