# Custom Generators in Python: A Complete Guide ðŸš€

Yes, we can **create custom generators** in Python using the `yield` keyword. Generators are a special type of iterator that **allow lazy evaluation**, meaning they generate values **on demand** instead of storing them in memory.

---

## ðŸ”¹ When to Create a Generator?
You should create a generator when:
1. **You need to process a large amount of data** efficiently (e.g., reading large files).
2. **You donâ€™t want to store the entire dataset in memory** (saves RAM).
3. **You need an infinite sequence** (like Fibonacci numbers).
4. **You need an iterator** that generates values dynamically.
5. **You want better performance** than lists.

---

## ðŸ”¹ Steps to Create a Custom Generator
Creating a generator involves three key steps:

### **Step 1: Define a Function with `yield`**
- Instead of `return`, use **`yield`** to return values one by one.
- Each time the generator function is called, it **remembers its last execution point** and resumes from there.

### **Step 2: Call the Function to Get a Generator Object**
- The function itself doesnâ€™t execute immediately.
- Calling it returns a generator **object**.

### **Step 3: Iterate Over the Generator**
- Use **`next()`** or a **`for` loop** to get values.

---

## ðŸ”¹ Example 1: A Simple Generator
Let's create a generator that **yields numbers from 1 to 5**.

```python
def simple_generator():
    print("Generator started")
    yield 1
    yield 2
    yield 3
    yield 4
    yield 5
    print("Generator finished")

# Creating generator object
gen = simple_generator()

# Using next() to get values one by one
print(next(gen))  # Output: 1
print(next(gen))  # Output: 2
print(next(gen))  # Output: 3

# Using a for loop to consume remaining values
for num in gen:
    print(num)
```

---

## ðŸ”¹ Example 2: Fibonacci Sequence Generator
A generator for generating **Fibonacci numbers** dynamically:

```python
def fibonacci_generator(limit):
    a, b = 0, 1
    for _ in range(limit):
        yield a
        a, b = b, a + b  # Update Fibonacci numbers

# Using the generator
fib_gen = fibonacci_generator(6)

for num in fib_gen:
    print(num)  # Output: 0, 1, 1, 2, 3, 5
```

---

## ðŸ”¹ Example 3: Infinite Number Generator
We can create an **infinite sequence** with a generator:

```python
def infinite_numbers():
    num = 1
    while True:
        yield num
        num += 1  # Increment number

# Get an infinite generator
gen = infinite_numbers()

# Get the first 5 numbers
for _ in range(5):
    print(next(gen))  # Output: 1, 2, 3, 4, 5
```
âš¡ **Be careful!** If you use a `for` loop without a condition, it will **run forever**.

---

## ðŸ”¹ Example 4: Read Large Files Efficiently
If you are reading a **large file**, instead of loading the entire file in memory, **use a generator**:

```python
def read_large_file(filename):
    with open(filename, "r") as file:
        for line in file:
            yield line.strip()  # Yield one line at a time

# Using the generator
for line in read_large_file("data.txt"):
    print(line)  # Reads line-by-line efficiently
```

---

## ðŸ”¹ Difference Between `yield` and `return`
| Feature | `yield` (Generator) | `return` (Normal Function) |
|---------|----------------------|----------------------------|
| **Memory Usage** | Efficient (does not store all values) | Loads all values in memory |
| **Execution** | Pauses & resumes execution | Function ends immediately |
| **State** | Remembers state | No memory of previous calls |
| **Looping** | Can be used in `for` loops | Returns a single result |

---

## ðŸ”¹ Conclusion
- **Use generators when handling large data or infinite sequences**.
- **They are memory efficient and improve performance**.
- **The `yield` keyword pauses and resumes execution** dynamically.

---

### ðŸš€ **Now you know how to create and use Python generators!** Let me know if you have any questions. ðŸ˜Š
